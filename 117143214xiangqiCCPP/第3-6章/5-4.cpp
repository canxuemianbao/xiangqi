#include <stdio.h>
#include <conio.h>

//---------------变量声明-----------------------------------------------
int side;					// 轮到哪方走，0表示红方，1表示黑方
unsigned char board[256];	// 棋盘数组
unsigned char piece[48];	// 棋子数组
char FenString[128];		// 局面的FEN串格式

typedef struct {
	unsigned char  from, to;
}move;
move MoveArray[128];	// 走法数组
int MoveNum;			// 走法总数，从1计数

//---------------函数声明-----------------------------------------------
//局面表示相关函数
void ClearBoard();		// 清空棋盘数组
void OutputBoard();		// 输出棋盘数组
void OutputPiece();		// 输出棋子数组
char IntToChar(int a);	// 棋子整数值转换成字符值
int CharToSubscript(char ch); // FEN串中棋子对应的数组下标
	//下标0，1，2，3，4，5，6分别对应表示将，仕，象，马，车，炮，兵

void AddPiece(int pos, int pc); // 在pos位置增加棋子pc
void StringToArray(const char *FenStr); //将FEN串表示的局面转换成一维数组
void ArrayToString();	// 将一维数组表示的局面转换成FEN串

//棋子走法生成函数
void KingMove(unsigned char p);		// 将的走法生成
void AdvisorMove(unsigned char p);	// 士的走法生成
void BishopMove(unsigned char p);	// 象的走法生成
void KnightMove(unsigned char p);	// 马的走法生成
void RookMove(unsigned char p);		// 车的走法生成
void CannonMove(unsigned char p);	// 炮的走法生成	
void PawnMove(unsigned char p);		// 兵的走法生成

//走法生成辅助函数
void InitGen();		//走法生成前的初始化操作
void SaveMove(unsigned char from, unsigned char t0);	//保存生成的走法
void GenAllMove();	//生成所有的走法
void OutputMove();	//输出所有的走法
int Check(int lSide);		//检测lSide一方是否被将军，是被将军返回1，否则返回0

//估值函数
short Eval(void);

//----------------走法生成相关辅助数组---------------------------------------------
//各种棋子走法数组
short KingDir[8] ={-0x10,		-0x01,	+0x01,	+0x10,	0,		0,		0,		0},//将
	AdvisorDir[8]={-0x11,		-0x0f,	+0x0f,	+0x11,	0,		0,		0,		0},		//士
	BishopDir[8] ={-0x22,		-0x1e,	+0x1e,	+0x22,	0,		0,		0,		0},	//象
	KnightDir[8] ={-0x21,		-0x1f,	-0x12,	-0x0e,	+0x0e,	+0x12,	+0x1f,	+0x21},	//马
	RookDir[8]   ={-0x01,		+0x01,	-0x10,	+0x10,	0,		0,		0,		0},		//车
	CannonDir[8] ={-0x01,		+0x01,	-0x10,	+0x10,	0,		0,		0,		0},		//炮
	PawnDir[2][8]={
			{-0x01,		+0x01,	-0x10,	0,		0,		0,		0,		0},
			{-0x01,		+0x01,	+0x10,	0,		0,		0,		0,		0}
		};		//兵

short KnightCheck[8] = {-0x10,-0x10,-0x01,+0x01,-0x01,+0x01,+0x10,+0x10};//马腿位置
short BishopCheck[8] = {-0x11,-0x0f,+0x0f,+0x11,0,0,0,0};	//象眼位置
short kingpalace[9] = {54,55,56,70,71,72,86,87,88};	//黑方九宫位置

//各种棋子合理位置数组
unsigned char LegalPosition[2][256] ={
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1,25, 1, 9, 1,25, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1, 9, 1, 9, 1, 9, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 17, 1, 1, 7, 19, 7, 1, 1, 17, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 3, 7, 3, 1, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 17, 7, 3, 7, 17, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	},
	{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 17, 7, 3, 7, 17, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 1, 1, 1, 3, 7, 3, 1, 1, 1, 0, 0, 0, 0,
		0, 0, 0, 17, 1, 1, 7, 19, 7, 1, 1, 17, 0, 0, 0, 0,
		0, 0, 0, 9, 1, 9, 1, 9, 1, 9, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 1,25, 1, 9, 1,25, 1, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	}
};
unsigned char PositionMask[7] = {2, 4, 16, 1, 1, 1, 8};

//估值相关数组
const char PieceNumToType[48] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6,
  0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6
};

const unsigned char PositionValues[2][7][256] = 
{
	{
		{ // 帅(将)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 10, 10, 10,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 15, 20, 15,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}, 
		{ // 仕(士)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}, 
		{ // 相(象)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 25,  0,  0,  0, 25,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 20,  0,  0,  0, 35,  0,  0,  0, 20,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 30,  0,  0,  0, 30,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}, 
		{// 马
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 70, 80, 90, 80, 70, 80, 90, 80, 70,  0,  0,  0,  0,
			0,  0,  0, 80,110,125, 90, 70, 90,125,110, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,125,120,125,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,130,110,130,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110,110,120,100,120,110,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,100,110,100,110,100,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80, 90,100,100, 90,100,100, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 80, 90, 90, 80, 90, 90, 80, 80,  0,  0,  0,  0,
			0,  0,  0, 70, 75, 75, 70, 50, 70, 75, 75, 70,  0,  0,  0,  0,
			0,  0,  0, 60, 70, 75, 70, 60, 70, 75, 70, 60,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},

		{ // 车
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,160,170,160,150,150,150,160,170,160,  0,  0,  0,  0,
			0,  0,  0,170,180,170,190,250,190,170,180,170,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,170,190,180,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,170,180,170,170,160,170,170,180,170,  0,  0,  0,  0,
			0,  0,  0,160,170,160,160,150,160,160,170,160,  0,  0,  0,  0,
			0,  0,  0,150,160,150,160,150,160,150,160,150,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}, 
		{ // 炮
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,125,130,100, 70, 60, 70,100,130,125,  0,  0,  0,  0,
			0,  0,  0,110,125,100, 70, 60, 70,100,125,110,  0,  0,  0,  0,
			0,  0,  0,100,120, 90, 80, 80, 80, 90,120,100,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90,110,130,110, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90, 90,110, 90, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 80, 80, 70, 80, 80,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 65, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 60, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}, 
		{ // 兵(卒)
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 10, 10, 10, 20, 25, 20, 10, 10, 10,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 40, 50, 60, 50, 40, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 30, 40, 40, 40, 30, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 20, 25, 25, 30, 30, 30, 25, 25, 20,  0,  0,  0,  0,
			0,  0,  0, 15, 20, 20, 20, 20, 20, 20, 20, 15,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 15,  0, 15,  0, 15,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 10,  0, 15,  0, 10,  0, 10,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}
	},
	{
		{//黑将
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 15, 20, 15,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 10, 10, 10,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑士
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0, 30,  0, 30,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0			
		},
		{//黑象
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 30,  0,  0,  0, 30,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 20,  0,  0,  0, 35,  0,  0,  0, 20,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0, 25,  0,  0,  0, 25,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑马
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 60, 70, 75, 70, 60, 70, 75, 70, 60,  0,  0,  0,  0,
			0,  0,  0, 70, 75, 75, 70, 50, 70, 75, 75, 70,  0,  0,  0,  0,
			0,  0,  0, 80, 80, 90, 90, 80, 90, 90, 80, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90,100,100, 90,100,100, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100,100,110,100,110,100,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110,110,120,100,120,110,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,130,110,130,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100,120,125,120,125,120,100, 90,  0,  0,  0,  0,
			0,  0,  0, 80,110,125, 90, 70, 90,125,110, 80,  0,  0,  0,  0,
			0,  0,  0, 70, 80, 90, 80, 70, 80, 90, 80, 70,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑车
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,150,160,150,160,150,160,150,160,150,  0,  0,  0,  0,
			0,  0,  0,160,170,160,160,150,160,160,170,160,  0,  0,  0,  0,
			0,  0,  0,170,180,170,170,160,170,170,180,170,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,180,190,170,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,180,220,210,240,250,240,210,220,180,  0,  0,  0,  0,
			0,  0,  0,170,190,200,220,240,220,200,190,170,  0,  0,  0,  0,
			0,  0,  0,170,180,170,190,250,190,170,180,170,  0,  0,  0,  0,
			0,  0,  0,160,170,160,150,150,150,160,170,160,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑炮
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 60, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 80, 90, 80, 70, 65, 70, 80, 90, 80,  0,  0,  0,  0,
			0,  0,  0, 90,100, 80, 80, 70, 80, 80,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90, 90,110, 90, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,100, 90,110,130,110, 90,100, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0, 90,110, 90,110,130,110, 90,110, 90,  0,  0,  0,  0,
			0,  0,  0,100,120, 90, 80, 80, 80, 90,120,100,  0,  0,  0,  0,
			0,  0,  0,110,125,100, 70, 60, 70,100,125,110,  0,  0,  0,  0,
			0,  0,  0,125,130,100, 70, 60, 70,100,130,125,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		},
		{//黑兵
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 10,  0, 15,  0, 10,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 10,  0, 15,  0, 15,  0, 15,  0, 10,  0,  0,  0,  0,
			0,  0,  0, 15, 20, 20, 20, 20, 20, 20, 20, 15,  0,  0,  0,  0,
			0,  0,  0, 20, 25, 25, 30, 30, 30, 25, 25, 20,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 30, 40, 40, 40, 30, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 25, 30, 40, 50, 60, 50, 40, 30, 25,  0,  0,  0,  0,
			0,  0,  0, 10, 10, 10, 20, 25, 20, 10, 10, 10,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
			0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
		}
	}
};

//--------------------函数实现----------------------------------

//棋子整数值转换成字符表示
char IntToChar(int a)
{
	if(a <32)
	{
		switch(a)
		{
		case 16:	return 'K';
		case 17:
		case 18:	return 'A';
		case 19:
		case 20:	return 'B';
		case 21:
		case 22:	return 'N';
		case 23:
		case 24:	return 'R';
		case 25:
		case 26:	return 'C';
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:	return 'P';
		default:	return 0;
		}
	}
	else
	{
		a = a-16;
		switch(a)
		{
		case 16:	return 'k';
		case 17:
		case 18:	return 'a';
		case 19:
		case 20:	return 'b';
		case 21:
		case 22:	return 'n';
		case 23:
		case 24:	return 'r';
		case 25:
		case 26:	return 'c';
		case 27:
		case 28:
		case 29:
		case 30:
		case 31:	return 'p';
		default:	return 0;
		}
	}
}

void ClearBoard() //清空棋盘数组
{
	int i;
	side = 0;
	for (i = 0; i < 256; i ++) 
	{
		board[i] = 0;
	}
	for (i = 0; i < 48; i ++) 
	{
		piece[i] = 0;
	}
}

//FEN串中棋子对应的数组下标
//下标0，1，2，3，4，5，6分别对应表示将，仕，象，马，车，炮，兵
int CharToSubscript(char ch) 
{
	switch(ch)
	{
	case 'k':
	case 'K':return 0;
	case 'a':
	case 'A':return 1;
	case 'b':
	case 'B':return 2;
	case 'n':
	case 'N':return 3;
	case 'r':
	case 'R':return 4;
	case 'c':
	case 'C':return 5;
	case 'p':
	case 'P':return 6;
	default:return 7;
	}
}

void AddPiece(int pos, int pc) //增加棋子
{
	board[pos] = pc;
	piece[pc] = pos;
}

//将FEN串表示的局面转换成一维数组
void StringToArray(const char *FenStr) 
{
	int i, j, k;
	int pcWhite[7]={16,17,19,21,23,25,27};
	int pcBlack[7]={32,33,35,37,39,41,43};
	const char *str;
  
	ClearBoard();
	str = FenStr;
	if (*str == '\0') 
	{
		return;
	}
  
	i = 3;
	j = 3;
	while (*str != ' ') 
	{
		if (*str == '/') 
		{
			j = 3;
			i ++;
			if (i > 12) 
			{
				break;
			}
		} 
		else if (*str >= '1' && *str <= '9') 
		{
			for (k = 0; k < (*str - '0'); k ++) 
			{
				if (j >= 11) 
				{
					break;
				}
				j ++;
			}
		} 
		else if (*str >= 'A' && *str <= 'Z') 
		{
			if (j <= 11) 
			{
				k = CharToSubscript(*str);
				if (k < 7) 
				{
					if (pcWhite[k] < 32) 
					{
						AddPiece((i<<4)+j,pcWhite[k]);
						pcWhite[k]++;
					}
				}
				j ++;
			}
		}
		else if (*str >= 'a' && *str <= 'z') 
		{
			if (j <= 11) 
			{
				k = CharToSubscript(*str);
				if (k < 7) 
				{
					if (pcBlack[k] < 48) 
					{
						AddPiece((i<<4)+j,pcBlack[k]);
						pcBlack[k]++;
					}
				}
				j ++;
			}
		}
		
		str ++;
		if (*str == '\0') 
		{
			return;
		}
	}
  	str ++;
  
	if (*str == 'b') 
		side = 1;
	else
		side = 0;
}

// 将一维数组表示的局面转换成FEN串
void ArrayToString()
{
	int i, j, k, pc;
	char *str;

	str = FenString;
	for (i = 3; i <= 12; i ++) 
	{
		k = 0;
		for (j = 3; j <= 11; j ++) 
		{
			pc = board[(i << 4) + j];
			if (pc != 0) 
			{
				if (k > 0) 
				{
					*str = k + '0';
					str ++;
					k = 0;
				}
				*str = IntToChar(pc);
				str ++;
			} 
			else 
			{
				k ++;
			}
		}
		if (k > 0) 
		{
			*str = k + '0';
			str ++;
		}
		*str = '/';
		str ++;
	}
	str --;
	*str = ' ';
	str ++;
	*str = (side == 0 ? 'w' : 'b');
	str ++;
	*str = '\0';
}

//输出棋盘数组
void OutputBoard()
{
	for(int i=1; i<=256; i++)
	{
		printf("%3d",board[i-1]);
		if(i%16==0)
			printf("\n");
	}
}

//输出棋子数组
void OutputPiece()
{
	int i;
	printf("棋子数组\n");
	for(i=0;i<16;i++)
		printf("%4d",piece[i]);
	printf("\n");
	for(i=16;i<32;i++)
		printf("%4d",piece[i]);
	printf("\n");
	for(i=32;i<48;i++)
		printf("%4d",piece[i]);
	printf("\n");
}

void InitGen()
{
	MoveNum = 0;
}

int Check(int lSide)	//检测lSide一方是否被将军，是被将军返回1，否则返回0
{
	unsigned char wKing,bKing; //红黑双方将帅的位置
	unsigned char p,q;
	int r;	//r=1表示将军，否则为0
	int SideTag = 32 - lSide * 16;	//此处表示lSide对方的将的值
	int fSide = 1-lSide;	//对方标志
	int i;
	int PosAdd;	//位置增量

	wKing = piece[16];
	bKing = piece[32];
	if(!wKing || !bKing)
		return 0;

	//检测将帅是否照面
	r=1;
	if(wKing%16 == bKing%16)
	{
		for(wKing=wKing-16; wKing!=bKing; wKing=wKing-16)
		{
			if(board[wKing])	
			{
				r=0;
				break;
			}
		}
		if(r)
			return r;	//将帅照面
	}

	q = piece[48-SideTag];	//lSide方将的位置

	//检测将是否被马攻击
	int k;
	unsigned char n;//下一步可能行走的位置
	unsigned char m;//马腿位置
	
	for(i=5;i<=6;i++)
	{
		p = piece[SideTag + i];
		if(!p)
			continue;
		for(k=0; k<8; k++)//8个方向
		{
			n = p + KnightDir[k];	//n为新的可能走到的位置
			if(n!=q)
				continue;

			if(LegalPosition[fSide][n] & PositionMask[3])	//马将对应下标为3
			{
				m = p + KnightCheck[k];
				if(!board[m])	//马腿位置无棋子占据
				{
					return 1;
				}
			}
		}
	}
	
	//检测将是否被车攻击
	r=1;
	for(i=7;i<=8;i++)
	{
		p = piece[SideTag + i];
		if(!p)
			continue;
		if(p%16 == q%16)	//在同一纵线上
		{
			PosAdd = (p>q?-16:16);
			for(p=p+PosAdd; p!=q; p = p+PosAdd)
			{
				if(board[p])	//车将中间有子隔着
				{
					r=0;
					break;
				}
			}
			if(r)
				return r;
		}
		else if(p/16 ==q/16)	//在同一横线上
		{
			PosAdd = (p>q?-1:1);
			for(p=p+PosAdd; p!=q; p = p+PosAdd)
			{
				if(board[p])
				{
					r=0;
					break;
				}
			}
			if(r)
				return r;
		}
	}
	
	//检测将是否被炮攻击
	int OverFlag = 0;	//翻山标志
	for(i=9;i<=10;i++)
	{
		p = piece[SideTag + i];
		if(!p)
			continue;
		if(p%16 == q%16)	//在同一纵线上
		{
			PosAdd = (p>q?-16:16);
			for(p=p+PosAdd; p!=q; p = p+PosAdd)
			{
				if(board[p])
				{
					if(!OverFlag)	//隔一子
						OverFlag = 1;
					else			//隔两子
					{
						OverFlag = 2;
						break;
					}
				}
			}
			if(OverFlag==1)
				return 1;
		}
		else if(p/16 ==q/16)	//在同一横线上
		{
			PosAdd = (p>q?-1:1);
			for(p=p+PosAdd; p!=q; p = p+PosAdd)
			{
				if(board[p])
				{
					if(!OverFlag)
						OverFlag = 1;
					else
					{
						OverFlag = 2;
						break;
					}
				}
			}
			if(OverFlag==1)
				return 1;
		}
	}

	//检测将是否被兵攻击
	for(i=11;i<=15;i++)
	{
		p = piece[SideTag + i];
		if(!p)
			continue;
		for(k=0; k<3; k++)//3个方向
		{
			n = p + PawnDir[fSide][k];	//n为新的可能走到的位置
			if((n==q) && (LegalPosition[fSide][n] & PositionMask[6]))	//兵士将对应下标为6
			{
				return 1;
			}
		}
	}
	return 0;
}
void SaveMove(unsigned char from, unsigned char to)
{
	unsigned char p;
	p = board[to];
	piece[board[from]] = to;
	if(p)
		piece[p]=0;
	board[to] = board[from];
	board[from] = 0;

	int r =Check(side);
	board[from] = board[to];
	board[to] = p;
	piece[board[from]] = from;
	if(p)
		piece[p] = to;

	if(!r)
	{
		MoveArray[MoveNum].from = from;
		MoveArray[MoveNum].to = to;
		MoveNum++;
	}
}

void KingMove(unsigned char p)
{
	int k;
	unsigned char n;//下一步可能行走的位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<4; k++)//4个方向
	{
		n = p + KingDir[k];	//n为新的可能走到的位置
		if(LegalPosition[side][n] & PositionMask[0])	//将对应下标为0
		{
			if( !(board[n] & SideTag))	//目标位置上没有本方棋子
				SaveMove(p, n);
		}
	}
}

void AdvisorMove(unsigned char p)
{
	int k;
	unsigned char n;//下一步可能行走的位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<4; k++)//4个方向
	{
		n = p + AdvisorDir[k];	//n为新的可能走到的位置
		if(LegalPosition[side][n] & PositionMask[1])	//士将对应下标为1
		{
			if( !(board[n] & SideTag))	//目标位置上没有本方棋子
				SaveMove(p, n);
		}
	}
}
void BishopMove(unsigned char p)
{
	int k;
	unsigned char n;//下一步可能行走的位置
	unsigned char m;//象眼位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<4; k++)//4个方向
	{
		n = p + BishopDir[k];	//n为新的可能走到的位置
		if(LegalPosition[side][n] & PositionMask[2])	//象将对应下标为2
		{
			m = p + BishopCheck[k];
			if(!board[m])	//象眼位置无棋子占据
			{
				if( !(board[n] & SideTag))	//目标位置上没有本方棋子
					SaveMove(p, n);
			}
		}
	}
}
void KnightMove(unsigned char p)
{
	int k;
	unsigned char n;//下一步可能行走的位置
	unsigned char m;//马腿位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<8; k++)//8个方向
	{
		n = p + KnightDir[k];	//n为新的可能走到的位置
		if(LegalPosition[side][n] & PositionMask[3])	//马将对应下标为3
		{
			m = p + KnightCheck[k];
			if(!board[m])	//马腿位置无棋子占据
			{
				if( !(board[n] & SideTag))	//目标位置上没有本方棋子
					SaveMove(p, n);
			}
		}
	}
}
void RookMove(unsigned char p)
{
	int k,j;
	unsigned char n;//下一步可能行走的位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<4; k++)	//4个方向
	{
		for(j=1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
		{
			n = p + j * RookDir[k];
			if(!(LegalPosition[side][n] & PositionMask[4]))	//车士将对应下标为4
				break;//不合理的位置
			if(! board[n] )	//目标位置上无子
				SaveMove(p, n);
			else if ( board[n] & SideTag)	//目标位置上有本方棋子
				break;
			else	//目标位置上有对方棋子
			{
				SaveMove(p, n);
				break;
			}
		}
	}
}
void CannonMove(unsigned char p)
{
	int k,j;
	unsigned char n;//下一步可能行走的位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	int OverFlag;

	for(k=0; k<4; k++)	//4个方向
	{
		OverFlag = 0;
		for(j=1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
		{
			n = p + j * CannonDir[k];
			if(!(LegalPosition[side][n] & PositionMask[5]))	//炮士将对应下标为5
				break;//不合理的位置
			if(! board[n] )	//目标位置上无子
			{
				if(!OverFlag)	//未翻山
					SaveMove(p, n);
				//已翻山则不作处理，自动考察向下一个位置
			}
			else//目标位置上有子
			{
				if (!OverFlag)	//未翻山则置翻山标志
					OverFlag = 1;
				else	//已翻山
				{
					if(! (board[n] & SideTag))//对方棋子
						SaveMove(p, n);
					break;	//不论吃不吃子，都退出此方向搜索
				}
			}
		}
	}
}
void PawnMove(unsigned char p)
{
	int k;
	unsigned char n;//下一步可能行走的位置
	int SideTag = 16 + side * 16;	//走棋方，红方16，黑方32
	for(k=0; k<3; k++)//3个方向
	{
		n = p + PawnDir[side][k];	//n为新的可能走到的位置
		if(LegalPosition[side][n] & PositionMask[6])	//兵士将对应下标为6
		{
			if( !(board[n] & SideTag))	//目标位置上没有本方棋子
				SaveMove(p, n);
		}
	}
}
void GenAllMove()
{
	short i;
	unsigned char p;	//p:棋子位置
	int SideTag;	//走棋方，经方16，黑方32
	int pc;	//棋子

	SideTag = 16 + 16 * side;
	
	for(i=0; i<16; i++)
	{
		pc = SideTag +i;
		p = piece[pc];
		if(p==0)
			continue;
		
		switch(i)
		{
		case 0:	//将
			KingMove(p);
			break;
		case 1:	//仕
		case 2:
			AdvisorMove(p);
			break;
		case 3:	//相
		case 4:
			BishopMove(p);
			break;
		case 5:	//马
		case 6:
			KnightMove(p);
			break;
		case 7:	//车
		case 8:
			RookMove(p);
			break;
		case 9:	//炮
		case 10:
			CannonMove(p);
			break;
		case 11://兵
		case 12:
		case 13:	
		case 14:
		case 15:
			PawnMove(p);
			break;
		}
	}
}

void OutputMove()
{
	int i;
	for(i=0; i<MoveNum; i++)
	{
		printf("from %3d to %3d\n",MoveArray[i].from,MoveArray[i].to);
	}
	printf("total move number:%d\n",MoveNum);
}

short Eval(void)
{
	short i,j,k,r;
	unsigned char p;	//p:棋子位置
	unsigned char n;	//下一步可能行走的位置
	unsigned char m;	//马腿、象眼位置
	int SideTag;		//走棋方，红方16，黑方32
	int OverFlag;		//炮的翻山标志	
	short bValue,wValue;
	short fValue[2]={0,0};	//灵活性分值
	bValue = wValue = 0;

	//计算固定位置分值
	for(i=16; i<32; i++)
	{
		if(piece[i]>0)
			wValue = wValue + PositionValues[0][PieceNumToType[i]][piece[i]];
	}

	for(i=32; i<48; i++)
	{
		if(piece[i]>0)
			bValue = bValue + PositionValues[1][PieceNumToType[i]][piece[i]];
	}


	//计算灵活性分值
	for(r=0;r<=1;r++)
	{
		SideTag = 16 + 16 * r;

		//将的灵活性
		for(k=0; k<4; k++)//4个方向
		{
			n = p + KingDir[k];	//n为新的可能走到的位置
			if(LegalPosition[side][n] & PositionMask[0])	//将对应下标为0
			{
				if( !(board[n] & SideTag))	//目标位置上没有本方棋子
					fValue[r]+=2;
			}
		}

		//士的灵活性
		for(i=1; i<=2; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<4; k++)//4个方向
			{
				n = p + AdvisorDir[k];	//n为新的可能走到的位置
				if(LegalPosition[side][n] & PositionMask[1])	//士将对应下标为1
				{
					if( !(board[n] & SideTag))	//目标位置上没有本方棋子
						fValue[r]+=2;
				}
			}
		}	
	
		//象的走法灵活性
		for(i=3; i<=4; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<4; k++)//4个方向
			{
				n = p + BishopDir[k];	//n为新的可能走到的位置
				if(LegalPosition[side][n] & PositionMask[2])	//象将对应下标为2
				{
					m = p + BishopCheck[k];
					if(!board[m])	//象眼位置无棋子占据
					{
						if( !(board[n] & SideTag))	//目标位置上没有本方棋子
							fValue[r]+=2;
					}
				}
			}
		}	
	
		//马的灵活性
		for(i=5; i<=6; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<8; k++)//8个方向
			{
				n = p + KnightDir[k];	//n为新的可能走到的位置
				if(LegalPosition[side][n] & PositionMask[3])	//马将对应下标为3
				{
					m = p + KnightCheck[k];
					if(!board[m])	//马腿位置无棋子占据
					{
						if( !(board[n] & SideTag))	//目标位置上没有本方棋子
							fValue[r]+=5;
					}
				}
			}
		}
	
		//车的灵活性
		for(i=7; i<=8; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<4; k++)	//4个方向
			{
				for(j=1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
				{
					n = p + j * RookDir[k];
					if(!(LegalPosition[side][n] & PositionMask[4]))	//车士将对应下标为4
						break;//不合理的位置
					if(! board[n] )	//目标位置上无子
					{
						fValue[r]+=4;
					}
					else if ( board[n] & SideTag)	//目标位置上有本方棋子
						break;
					else	//目标位置上有对方棋子
					{
						fValue[r]+=4;
						break;
					}
				}
			}
		}

		//炮的灵活性
		for(i=9; i<=10; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<4; k++)	//4个方向
			{
				OverFlag = 0;
				for(j=1; j<10; j++)	//横的最多有8个可能走的位置，纵向最多有9个位置
				{
					n = p + j * CannonDir[k];
					if(!(LegalPosition[side][n] & PositionMask[5]))	//炮士将对应下标为5
						break;//不合理的位置
					if(! board[n] )	//目标位置上无子
					{
						if(!OverFlag)	//未翻山
							fValue[r]+=3;
						//已翻山则不作处理，自动考察向下一个位置
					}
					else//目标位置上有子
					{
						if (!OverFlag)	//未翻山则置翻山标志
							OverFlag = 1;
						else	//已翻山
						{
							if(! (board[n] & SideTag))//对方棋子
								fValue[r]+=3;
							break;	//不论吃不吃子，都退出此方向搜索
						}
					}
				}
			}	
		}

		//兵的灵活性
		for(i=11; i<=15; i++)
		{
			p = piece[SideTag + i];
			if(!p)
				continue;
			for(k=0; k<3; k++)//3个方向
			{
				n = p + PawnDir[side][k];	//n为新的可能走到的位置
				if(LegalPosition[side][n] & PositionMask[6])	//兵士将对应下标为6
				{
					if( !(board[n] & SideTag))	//目标位置上没有本方棋子
						fValue[r]+=2;
				}
			}
		}
	
	}

	return fValue[0] - fValue[1] + wValue - bValue;
}


void main()
{
	printf("****************************************************************\n");
	printf(" 示例程序4-3             走 法 生 成\n");
	printf("\n");
	printf("                                作者：蒋鹏\n");
	printf("                                时间：2007-8-29\n");
	printf("****************************************************************\n");
	printf("初始局面\n");
	StringToArray("rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1");
//	StringToArray("4k4/9/5a3/4p4/4C4/9/5R3/3nB4/9/2BAKA2r w - - 0 1");
	OutputBoard();

	OutputPiece();

	printf("生成的走法\n");
	InitGen();
	GenAllMove();
	OutputMove();

	getch();
}